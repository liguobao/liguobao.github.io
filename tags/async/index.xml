<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Async on Life Deletion Guide</title><link>https://liguobao.github.io/tags/async/</link><description>Recent content in Async on Life Deletion Guide</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 07 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://liguobao.github.io/tags/async/index.xml" rel="self" type="application/rss+xml"/><item><title>A DI Misstep That Cascaded into Startup Incidents</title><link>https://liguobao.github.io/p/a-di-misstep-that-cascaded-into-startup-incidents/</link><pubDate>Sun, 07 Jun 2020 00:00:00 +0000</pubDate><guid>https://liguobao.github.io/p/a-di-misstep-that-cascaded-into-startup-incidents/</guid><description>&lt;p&gt;Symptoms: on startup, the first wave of traffic produced no responses while health checks looked OK, so the k8s LB kept routing, requests piled up, DB connections spiked, and pods flapped.&lt;/p&gt;
&lt;p&gt;What it wasn’t: not a DB bottleneck (CPU/IO fine), not EF per se, not external infra issues.&lt;/p&gt;
&lt;p&gt;Contributing factors and fixes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Warm up DB connections and EF metadata (limited effect).&lt;/li&gt;
&lt;li&gt;Make controller/service code truly async end‑to‑end (notably improved p50/p95 and reduced startup pileups).&lt;/li&gt;
&lt;li&gt;Pre‑warm instances before cutting traffic over to reduce cold‑start jitter.&lt;/li&gt;
&lt;li&gt;Be careful with filters that do network/Redis/MaxMind work during request entry; ensure these calls are async, cached, and bounded.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Root cause: a dependency injected component with expensive sync work on the hot path during startup. Fixing the DI lifetime and making the path fully async eliminated the cascade.&lt;/p&gt;</description></item></channel></rss>