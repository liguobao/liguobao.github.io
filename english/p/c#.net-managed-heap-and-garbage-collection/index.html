<!doctype html><html lang=english dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content=".NET Managed Heap and Garbage Collection Basics of Managed Heap Brief description: Every program needs to use resources of one kind or another, including files, memory buffers, screen space, network connections&mldr;.. In fact, in an object-oriented environment, each type represents a resource available to the program. To use these resources, memory must be allocated for the type representing the resource.\nThe following are the steps required to access a resource:\n"><title>C#.NET Managed Heap and Garbage Collection</title><link rel=canonical href=https://liguobao.github.io/english/p/c%23.net-managed-heap-and-garbage-collection/><link rel=stylesheet href=/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css><meta property='og:title' content="C#.NET Managed Heap and Garbage Collection"><meta property='og:description' content=".NET Managed Heap and Garbage Collection Basics of Managed Heap Brief description: Every program needs to use resources of one kind or another, including files, memory buffers, screen space, network connections&mldr;.. In fact, in an object-oriented environment, each type represents a resource available to the program. To use these resources, memory must be allocated for the type representing the resource.\nThe following are the steps required to access a resource:\n"><meta property='og:url' content='https://liguobao.github.io/english/p/c%23.net-managed-heap-and-garbage-collection/'><meta property='og:site_name' content='Lift Deleted Guide'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='dotnet core'><meta property='article:published_time' content='2016-10-04T00:00:00+00:00'><meta property='article:modified_time' content='2016-10-04T00:00:00+00:00'><meta name=twitter:title content="C#.NET Managed Heap and Garbage Collection"><meta name=twitter:description content=".NET Managed Heap and Garbage Collection Basics of Managed Heap Brief description: Every program needs to use resources of one kind or another, including files, memory buffers, screen space, network connections&mldr;.. In fact, in an object-oriented environment, each type represents a resource available to the program. To use these resources, memory must be allocated for the type representing the resource.\nThe following are the steps required to access a resource:\n"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/english/><img src=/img/zhihu-lgb_hu_b21b612b464d8faa.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/english>Lift Deleted Guide</a></h1><h2 class=site-description>liguobao</h2></div></header><ol class=menu-social><li><a href=https://github.com/liguobao target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://x.com/Liguobao2049 target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li><li><a href=https://www.zhihu.com/people/codelover target=_blank title=知乎 rel=me><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/english/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/english/liguobao-resume/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>About</span></a></li><li><a href=/english/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/english/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://liguobao.github.io/>简体中文</option><option value=https://liguobao.github.io/english/ selected>English</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#basics-of-managed-heap>Basics of Managed Heap</a></li><li><a href=#allocating-resources-from-the-managed-heap>Allocating Resources from the Managed Heap</a></li><li><a href=#the-new-operator-in-c-causes-clr-to-perform-the-following-operations>The new operator in C# causes CLR to perform the following operations:</a><ol><li><a href=#garbage-collection-algorithm>Garbage Collection Algorithm</a><ol><li><a href=#clr-uses-reference-tracking-algorithm>CLR uses reference tracking algorithm.</a></li></ol></li></ol></li><li><a href=#generations-improving-performance-to-be-continued>Generations: Improving Performance (To be continued)</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/english/p/c%23.net-managed-heap-and-garbage-collection/>C#.NET Managed Heap and Garbage Collection</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 04, 2016</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 10 分钟</time></div></footer><footer class=article-translations><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><div><a href=https://liguobao.github.io/p/c%23.net%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/ class=link>简体中文</a></div></footer></div></header><section class=article-content><h1 id=net-managed-heap-and-garbage-collection>.NET Managed Heap and Garbage Collection</h1><h2 id=basics-of-managed-heap>Basics of Managed Heap</h2><p>Brief description: Every program needs to use resources of one kind or another, including files, memory buffers, screen space, network connections&mldr;.. In fact, in an object-oriented environment, each type represents a resource available to the program. To use these resources, memory must be allocated for the type representing the resource.</p><p>The following are the steps required to access a resource:</p><ol><li>Call the IL instruction newobj to allocate memory for the type representing the resource. (C# new operator)</li><li>Initialize the memory to set the initial state of the resource. (Generally refers to the constructor)</li><li>Access the type&rsquo;s members to use the resource. (Use member variables, methods, properties, etc.)</li><li>Destroy the resource&rsquo;s state for cleanup. (Dispose???)</li><li>Free the memory. (GC)</li></ol><h2 id=allocating-resources-from-the-managed-heap>Allocating Resources from the Managed Heap</h2><p>CLR requires all objects to be allocated from the managed heap.</p><p>When the process initializes, CLR allocates an address space region as the managed heap. CLR also maintains a pointer, let&rsquo;s call it NextObjPtr, which points to the allocation position of the next object in the heap. At the beginning, NextObjPtr is set to the base address of the address space region.</p><p>When a region is filled with non-garbage objects, CLR allocates more regions.</p><p>This process repeats until the entire process address space is filled. So, application memory is limited by the process&rsquo;s virtual address space.</p><p>32-bit processes can allocate up to 1.5GB, 64-bit processes can allocate up to 8T.</p><p>Note: Related materials on process memory size</p><p><a class=link href="https://msdn.microsoft.com/zh-cn/library/windows/hardware/Dn613959%28v=vs.85%29.aspx" target=_blank rel=noopener>Memory Support and Windows Operating Systems</a></p><p><a class=link href=https://msdn.microsoft.com/zh-cn/library/ms189334.aspx target=_blank rel=noopener>Process Address Space</a></p><p><a class=link href=http://blog.csdn.net/yusiguyuan/article/details/12405799 target=_blank rel=noopener>Maximum memory available for C/C++ programs in 32-bit mode</a></p><h2 id=the-new-operator-in-c-causes-clr-to-perform-the-following-operations>The new operator in C# causes CLR to perform the following operations:</h2><ol><li><p>Calculate the number of bytes required for the type&rsquo;s fields (and fields inherited from base types).</p></li><li><p>Add the bytes required for object overhead. Each object has two overhead fields: type object pointer and sync block index. For 32-bit applications, these two fields each require 32 bits, so each object needs to add 8 bytes. For 64-bit applications, these two fields each require 64 bits, so each object adds 16 bytes.</p></li><li><p>CLR checks if there are enough bytes in the region to allocate the object. If the managed heap has enough available space, the object is placed at the address pointed to by the NetxObjPtr pointer, and the bytes allocated for the object are zeroed. Then the type&rsquo;s constructor is called (passing NextObjPtr as the this parameter), the new operator returns the object reference. Just before returning the object reference, the value of the NextObjPtr pointer is increased by the number of bytes occupied by the object to get a new value, which is the address where the next object will be placed in the managed heap. As shown in the figure:</p></li></ol><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/i3rlSCPAcnT9pL0El0BptPIBpuvnxHpBw9Nkp*UqIjw!/o/dJMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=LwKNAC8CjQADACU!&amp;su=1199793361&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=tup></p><h3 id=garbage-collection-algorithm>Garbage Collection Algorithm</h3><h4 id=clr-uses-reference-tracking-algorithm>CLR uses reference tracking algorithm.</h4><p>Reference tracking algorithm only cares about reference type variables, because only this type of variable can reference objects on the heap;</p><p>Value type variables directly contain value type instances. Reference type variables can be used in many situations, including static and instance fields of classes, or parameters and local variables of methods. Here we call all reference type variables roots.</p><p>When CLR starts GC, it first suspends all threads. (This prevents threads from accessing objects and changing their state during CLR inspection.) Then CLR enters the GC marking phase. In this phase, CLR traverses all objects in the heap, setting a bit in the sync block index field to 0. This indicates that all objects should be deleted. Then, CLR checks all active roots to see which objects they reference. This is why CLR&rsquo;s GC is called reference tracking GC. If a root contains null, CLR ignores this root and continues to check the next root.</p><p>The figure below shows a heap containing several objects.</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/eVBVeXGrNAfoWfyRgl4aC2RRSGgiDpmbrocv4lTSJMA!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=gAIFAYACBQEDACU!&amp;su=1176931729&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=图片1></p><p>The application&rsquo;s roots directly reference objects A, C, D, F. All objects have been marked. When marking object D, GC finds that this object contains a field referencing object H, causing object H to also be marked. The marking process continues until all roots of the application have been checked.</p><p>After checking, the objects in the heap are either marked or unmarked. Marked objects cannot be garbage collected because at least one root is referencing them. We say that such objects are reachable because the application can reach them through variables referencing them. Unmarked objects are unreachable because there is no root in the application that can make the object accessible again.</p><p>After CLR knows which objects can survive and which can be deleted, it enters the GC compression (similar to defragmentation) phase. In the compression phase, CLR &ldquo;moves&rdquo; the marked objects in the heap to organize all surviving objects to occupy contiguous memory.</p><p>The benefits of doing this are:</p><ol><li><p>All surviving objects are next to each other in memory, restoring the &ldquo;locality&rdquo; of references, reducing the application&rsquo;s working set, thereby improving performance when accessing these objects in the future;</p></li><li><p>After defragmentation, the available space is also contiguous, liberating the entire address space segment, allowing other things to reside.</p></li></ol><p>After moving objects in memory, there is a problem that needs to be solved urgently. The roots referencing surviving objects now reference the original location of the object in memory, not the moved location. When suspended threads resume execution, they will access the old memory location, causing memory corruption. This is obviously intolerable, so as part of the compression phase, CLR also subtracts the number of bytes the referenced object is offset in memory from each root. This ensures that each root still references the same object as before, only the object&rsquo;s position in memory has changed.</p><p>As shown in the figure:</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/FyP2yk1O6kMsq3.u4e4x3qrAxpwbajgSHOd4QHTJOhE!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=TQI*AU0CPwEDACU!&amp;su=1202148209&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=123></p><h2 id=generations-improving-performance-to-be-continued>Generations: Improving Performance (To be continued)</h2><p>CLR&rsquo;s GC is a generational garbage collector, it makes the following assumptions about your code:</p><ol><li><p>The newer the object, the shorter the lifetime.</p></li><li><p>The older the object, the longer the lifetime.</p></li><li><p>Recycling part of the heap is faster than recycling the entire heap.</p></li></ol><p>Extensive research shows that these assumptions hold for most applications today, and they affect the implementation of the garbage collector. Here we will explain how generations work.</p><p>The managed heap does not include objects when initialized. Objects added to the heap become generation 0 objects. Simply put, generation 0 objects are those newly constructed objects that the garbage collector has never checked. As shown in the figure, a newly started application has allocated 5 objects (A to E). After a while, C and E become unreachable.</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/77WJus7lssJpEJ2RZREQoNx.5CL31HLdboJbAgCqS0E!/o/dJMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=tQIVAbUCFQEDACU!&amp;su=172682065&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=23></p><p>CLR initializes generation 0 objects by selecting a budget capacity. If allocating a new object causes generation 0 to exceed the budget, a GC must be started. Assuming objects A to E just fill generation 0&rsquo;s space, allocating object F must start GC. After GC, surviving objects become generation 1 objects. As shown in the figure:</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/GEDzaV4pNFNQUuDwl2EQrv*eD9Sk9OJCzx5SpRRI2fk!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=OAL5ADgC.QADACU!&amp;su=1155276897&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=123></p><p>After one GC, generation 0 does not contain any objects. As before, new objects will be allocated to generation 0. Newly allocated objects F to K all go to generation 0.</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/Op0QokzBTNYCFR6zzm2tpc2V7U70IsIJTeWrd0UAUb0!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=yAJeAcgCXgEDACU!&amp;su=1124261217&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=234></p><p>Then, the program continues to run, B, H, J become unreachable, their memory will be recycled at some point.</p><p>Assume that allocating new object L will cause generation 0 to exceed the budget, causing GC to start.</p><p>When starting garbage collection, the garbage collector must decide which generations to check. As mentioned earlier, CLR initializes by selecting a budget for generation 0 objects. In fact, it must also select a budget for generation 1.</p><p>When starting a garbage collection, the garbage collector also checks how much memory generation 1 occupies. In this example, since generation 1 occupies much less memory than the budget, the garbage collector decides to check only generation 0 objects. Recalling the first assumption made by the generational garbage collector: the newer the object, the shorter the lifetime. Therefore, generation 0 contains more garbage, and more memory can be recycled. By ignoring objects in generation 1, the garbage collection speed is accelerated.</p><p>Obviously, ignoring objects in generation 1 can improve the performance of the garbage collector. But what has a greater performance boost is that now there is no need to traverse every object in the managed heap. If a root or object references an object in an older generation, the garbage collector can ignore all references inside the old object, and can construct the reachable object graph in a shorter time. Of course, if the fields of old objects may also reference new objects. To ensure that updated fields of old objects are checked, the garbage collector uses a mechanism inside the JIT compiler. This mechanism sets a corresponding flag when the reference field of an object changes. In this way, the garbage collector knows which old objects (if any) have been written to since the last garbage collection. Only old objects whose fields have changed need to be checked to see if they reference any new objects in generation 0.</p><p>The generational garbage collector also assumes that the older the object, the longer it lives. That is, generation 1 objects are likely to continue to be reachable in the application. If the garbage collector checks the objects in generation 1, it is likely to find little garbage, and as a result, little memory can be recycled. Therefore, garbage collecting generation 1 is likely to be a waste of time. If there is really garbage in generation 1, the garbage will stay there. As shown in the figure:</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/Do.yRCBJEnaOfZaUOdxj4II9*pX2BEcX2QmIG6NQPBE!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=qAI5AagCOQEDACU!&amp;su=187009937&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=2345></p><p>The program continues to run, continues to allocate objects to generation 0, and at the same time the program stops using some objects in generation 1.</p><p>As shown in the figure:</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/YEqIM16xFsSgXdvEzgrerLnKw7fEItnrSqEzlaYnUfE!/o/dGUBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=egJPAXoCTwEDACU!&amp;su=1118118497&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=edf></p><p>Allocating object P causes generation 0 to exceed the budget, starting GC. All objects in generation 1 still occupy less than the budget, the garbage collector decides again to recycle only generation 0. Ignore garbage objects in generation 1. As shown in the figure:</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/EcdSNU5AatqRERWtVdlJ7LiIPHHXe8.mklN.0hHDK9U!/o/dJQAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=aAIxAWgCMQEDACU!&amp;su=1214124305&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=2345></p><p>The program continues to run, assuming that the growth of generation 1 causes all its objects to occupy the full budget. At this time, the application allocates objects P to S, making the generation 0 objects reach their budget total. As shown in the figure:</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/6dB68RIUYrqMZ4p0VIY3REJZPg.g3ybkZFIazJ3h.CQ!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=jwIiAY8CIgEDACU!&amp;su=177976657&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=43></p><p>At this time, the application is ready to allocate object T, since generation 1 is full, GC must start. But this time the garbage collector finds that generation 1 occupies too much memory, using up the budget. Since the previous GC on generation 0, there may already be many unreachable objects in generation 1. So this time the garbage collector decides to check all objects in generation 1 and generation 0. After garbage collection of both generations, the heap looks like the figure:</p><p><img src="http://r.photo.store.qq.com/psb?/4d3e65a5-4593-42bc-88f9-7bbb2e647ebe/bxdZDsZi2Y6FSDWs7RXNPkkJK8dCzMD.cfnjwNY2Mjs!/o/dJIAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=tgI2AbYCNgEDACU!&amp;su=197762641&amp;sce=0-12-12&amp;rf=2-9" loading=lazy alt=123></p><p>The managed heap only supports three generations: generation 0, generation 1, and generation 2.</p><p>When CLR initializes, it selects a budget for each generation.</p><p>However, CLR&rsquo;s garbage collection is self-adjusting.</p><p>This means that the garbage collector learns about the program&rsquo;s behavior during the garbage collection process.</p><p>For example: Assume that the application constructs many objects, but each object has a very short lifetime.</p><p>In this case, garbage collection of generation 0 will recycle a large amount of memory. In fact, all objects in generation 0 may be recycled.</p><p>If the garbage collector finds that after recycling generation 0, few objects survive, it may reduce the budget for generation 0. The reduction in allocated space means that garbage collection will occur more frequently, but the garbage collector does less each time, which reduces the process&rsquo;s working set.</p><p>On the other hand, if the garbage collector recycles generation 0 and finds that many objects survive, little memory can be recycled, it will increase the budget for generation 0.</p><p>The same heuristic algorithm adjusts the budget for generation 1 and generation 2.</p><p>Quoted from: &ldquo;CLR VIA C# - Chapter 21&rdquo;</p><p><a class=link href="https://msdn.microsoft.com/zh-cn/library/vstudio/f144e03t%28v=vs.100%29.aspx" target=_blank rel=noopener>Automatic Memory Management</a></p><p><a class=link href="https://msdn.microsoft.com/zh-cn/library/vstudio/ee787088%28v=vs.100%29.aspx" target=_blank rel=noopener>Fundamentals of Garbage Collection</a></p><p><a class=link href="https://msdn.microsoft.com/zh-cn/library/vstudio/ee787088%28v=vs.100%29.aspx#generations" target=_blank rel=noopener>Generations</a></p></section><footer class=article-footer><section class=article-tags><a href=/english/tags/dotnet-core/>Dotnet Core</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><script src=https://utteranc.es/client.js repo=liguobao/liguobao.github.io issue-term=title crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Lift Deleted Guide</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>